<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Snake — GPT-5 Edition</title>
  <style>
    :root{
      --bg1:#050510; --bg2:#0a0020; --grid:#16162a;
      --neon1:#00f6ff; --neon2:#7c00ff; --neon3:#39ff14; --neon4:#ff2bd6; --text:#e6e6ff;
      --snake:#00e5ff; --apple:#ff2965; --gold:#ffd166;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--text);
      background: radial-gradient(1200px 800px at 20% 10%, rgba(124,0,255,0.15), transparent 60%),
                  radial-gradient(900px 700px at 80% 30%, rgba(0,246,255,0.12), transparent 60%),
                  linear-gradient(180deg, var(--bg2), var(--bg1));
      overflow:hidden;
    }
    header{
      text-align:center; padding:14px 12px 8px; position:relative;
      text-shadow:0 0 8px rgba(124,0,255,.7), 0 0 18px rgba(0,246,255,.5);
    }
    h1{margin:0; font-weight:800; letter-spacing:.5px; font-size:clamp(18px, 2.6vw, 26px)}
    .subtitle{opacity:.9; font-size:clamp(12px, 1.8vw, 14px)}
    .attribution{position:absolute; right:12px; top:12px; font-size:12px; opacity:.9}

    .wrap{display:flex; flex-direction:column; align-items:center; gap:10px; height:calc(100% - 70px)}

    .hud{display:flex; gap:16px; align-items:center; justify-content:center; font-size:14px; opacity:.95}
    .pill{padding:6px 10px; border:1px solid #2a2a48; border-radius:999px; background:rgba(10,10,30,.35); box-shadow:inset 0 0 12px rgba(124,0,255,.15)}
    .pill.clickable{cursor:pointer; -webkit-user-select:none; user-select:none}
    .pill.clickable:active{transform:translateY(1px)}

    .stage{
      position:relative; flex:1; width:100%; max-width:min(92vmin, 720px); align-self:center;
      display:flex; align-items:center; justify-content:center; padding:8px 10px 14px;
    }

    canvas{
      width:100%; height:auto; aspect-ratio:1/1; max-height:80vh;
      background:linear-gradient(180deg, rgba(10,10,30,.55), rgba(5,5,16,.75));
      border-radius:16px; border:1px solid #252545;
      box-shadow: 0 0 0 2px rgba(124,0,255,.15), 0 20px 60px rgba(0,0,0,.6), inset 0 0 30px rgba(0,246,255,.08);
      image-rendering: pixelated;
      touch-action:none; /* we'll manage gestures */
    }

    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column;
      pointer-events:none; text-align:center; padding:16px;
    }
    /* Ensure overlay truly hides across browsers when using the hidden attribute */
    .overlay[hidden]{ display:none !important; }
    .overlay .panel{
      pointer-events:auto; background:rgba(8,8,24,.75); border:1px solid #2a2a48; border-radius:14px; padding:14px 16px;
      box-shadow:0 0 18px rgba(124,0,255,.25), 0 0 30px rgba(0,246,255,.12);
      -webkit-backdrop-filter: blur(6px);
      backdrop-filter: blur(6px);
    }
    .btn{
      display:inline-block; margin-top:10px; padding:8px 14px; border-radius:999px; cursor:pointer; -webkit-user-select:none; user-select:none;
      border:1px solid #2a2a48; background:linear-gradient(180deg, rgba(124,0,255,.35), rgba(0,246,255,.25)); color:var(--text);
      box-shadow:0 0 12px rgba(124,0,255,.45), inset 0 0 10px rgba(0,246,255,.25);
    }
    .btn:active{transform:translateY(1px)}
    /* Overlay message text */
    .msg{font-weight:700; margin-bottom:8px; text-shadow:0 0 8px rgba(57,255,20,.8)}

    footer{font-size:12px; text-align:center; opacity:.8; padding:6px 10px 12px}

    /* Mobile hint */
    .swipe-hint{font-size:12px; opacity:.8}
  </style>
</head>
<body>
  <header>
    <h1>Neon Snake — Created with GPT-5</h1>
    <div class="subtitle">Arrow keys or swipe to play • Retro neon vibes</div>
    <div class="attribution">Single-file, no dependencies</div>
  </header>

  <div class="wrap">
    <div class="hud">
      <div class="pill">Score: <span id="score" aria-live="polite">0</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <div class="pill">Speed: <span id="speed">1x</span></div>
      <div id="modeToggle" class="pill clickable" title="Toggle wrap/walls">Mode: <span id="modeLabel">Wrap</span></div>
      <div id="soundToggle" class="pill clickable" title="Toggle sound">Sound: <span id="soundLabel">Off</span></div>
      <div id="resetBest" class="pill clickable" title="Reset best score">Reset Best</div>
    </div>

    <div class="stage">
      <canvas id="board" width="600" height="600" aria-label="Snake game board" role="img"></canvas>
      <div id="overlay" class="overlay" hidden>
        <div class="panel">
          <div id="message" class="msg" aria-live="polite">Tap or press space to start</div>
          <div class="swipe-hint">On mobile: swipe anywhere to move</div>
          <div class="btn" id="startBtn">Start</div>
        </div>
      </div>
    </div>

    <footer>Tip: Avoid reversing into yourself • Pause/Resume with Space • Reset with R</footer>
  </div>

  <script>
  ;(() => {
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const message = document.getElementById('message');
    const startBtn = document.getElementById('startBtn');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const speedEl = document.getElementById('speed');
    const modeToggle = document.getElementById('modeToggle');
    const modeLabel = document.getElementById('modeLabel');
    const soundToggle = document.getElementById('soundToggle');
    const soundLabel = document.getElementById('soundLabel');
    const resetBestBtn = document.getElementById('resetBest');

    // Game config
    const BASE_TPS = 10; // ticks per second
    const GRID_MIN = 14, GRID_MAX = 26; // grid cells per side depending on viewport
    const GROWTH = 2; // segments per apple

    // State
    let gridSize = 20; // cells per side
    let cell = 24; // px computed
    let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    let snake = [];
    let dir = {x:1, y:0};
    let nextDir = {x:1, y:0};
    let apple = {x:5, y:5};
    let score = 0; let best = Number(localStorage.getItem('neon-snake-best')||0);
    let speedMult = 1;
    let running = false; let paused = false; let gameOver = false;
    let pendingGrowth = 0;

    // Options
    let walls = localStorage.getItem('neon-snake-walls') === '1';
    let soundEnabled = localStorage.getItem('neon-snake-sound') === '1';

    // Simple WebAudio beeps
    let audioCtx = null;
    function ensureAudio(){
      if(!soundEnabled) return;
      if(!audioCtx){
        try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch{ audioCtx = null; }
      }
      if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    }
    function beep(type){
      if(!soundEnabled) return;
      ensureAudio(); if(!audioCtx) return;
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      if(type==='eat'){ o.frequency.value = 880; }
      else if(type==='over'){ o.frequency.value = 220; }
      else if(type==='pause'){ o.frequency.value = 440; }
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
      o.connect(g).connect(audioCtx.destination);
      o.start(now); o.stop(now+0.13);
    }

    // Resize handling for responsive grid
    function computeGrid(){
      const rect = canvas.getBoundingClientRect();
      const minSide = Math.min(rect.width, rect.height || rect.width);
      // Choose grid size based on viewport so cells are about 18-28px
      const targetCell = Math.max(18, Math.min(28, Math.round(minSide / 22)));
      gridSize = Math.max(GRID_MIN, Math.min(GRID_MAX, Math.floor(minSide / targetCell)));
      cell = Math.floor(minSide / gridSize);

      // Resize canvas for DPR crispness
      const size = cell * gridSize;
      canvas.width = Math.floor(size * dpr);
      canvas.height = Math.floor(size * dpr);
      canvas.style.height = size + 'px';
      canvas.style.width = size + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function resetGame(){
      computeGrid();
      const cx = Math.floor(gridSize/2);
      snake = [ {x:cx-1,y:cx}, {x:cx,y:cx}, {x:cx+1,y:cx} ];
      dir = {x:1,y:0}; nextDir = {x:1,y:0};
      score = 0; speedMult = 1; paused=false; gameOver=false; running=false; pendingGrowth = 0;
      placeApple();
      updateHUD();
      showOverlay('Tap or press space to start');
    }

    function updateHUD(){
      scoreEl.textContent = score;
      bestEl.textContent = best;
      speedEl.textContent = speedMult.toFixed(1)+'x';
    }

    function showOverlay(msg){
      message.textContent = msg;
      overlay.hidden = false;
    }
    function hideOverlay(){
      overlay.hidden = true;
    }

    function placeApple(){
      const empty = [];
      const used = new Set(snake.map(s=> s.x+','+s.y));
      for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){
        const key = x+','+y; if(!used.has(key)) empty.push({x,y});
      }
      apple = empty.length ? empty[Math.floor(Math.random()*empty.length)] : {x:0,y:0};
    }

    function setDirection(nx, ny){
      // prevent 180 reverse
      if(nx === -dir.x && ny === -dir.y) return;
      nextDir = {x:nx, y:ny};
    }

    // Input — keyboard
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d',' '].includes(k)) e.preventDefault();
      if(k==='arrowup'||k==='w') setDirection(0,-1);
      else if(k==='arrowdown'||k==='s') setDirection(0,1);
      else if(k==='arrowleft'||k==='a') setDirection(-1,0);
      else if(k==='arrowright'||k==='d') setDirection(1,0);
      else if(k===' '){
        if(!running || gameOver) startGame();
        else { paused = !paused; if(paused) showOverlay('Paused — press Space to resume'); else hideOverlay(); }
      } else if(k==='r') { resetGame(); }
    }, {passive:false});

    startBtn.addEventListener('click', ()=> startGame());
    overlay.addEventListener('click', ()=> startGame());
    resetBestBtn.addEventListener('click', () => {
      best = 0; localStorage.setItem('neon-snake-best','0'); updateHUD();
    });

    // Mode toggle (Wrap vs Walls)
    function updateModeLabel(){ modeLabel.textContent = walls ? 'Walls' : 'Wrap'; }
    updateModeLabel();
    modeToggle.addEventListener('click', () => {
      walls = !walls; localStorage.setItem('neon-snake-walls', walls? '1':'0'); updateModeLabel();
    });

    // Sound toggle
    function updateSoundLabel(){ soundLabel.textContent = soundEnabled ? 'On' : 'Off'; }
    updateSoundLabel();
    soundToggle.addEventListener('click', () => {
      soundEnabled = !soundEnabled; localStorage.setItem('neon-snake-sound', soundEnabled? '1':'0'); updateSoundLabel(); ensureAudio();
    });

    // Input — touch swipe
    let touchStart=null;
    const SWIPE_MIN = 18; // px

    function onTouchStart(e){ if(e.touches.length){ touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY}; } }
    function onTouchMove(e){ if(!touchStart) return; e.preventDefault(); }
    function onTouchEnd(e){
      if(!touchStart) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStart.x; const dy = t.clientY - touchStart.y;
      const adx = Math.abs(dx), ady = Math.abs(dy);
      if(adx<SWIPE_MIN && ady<SWIPE_MIN){ touchStart=null; return; }
      if(adx>ady) setDirection(dx>0?1:-1,0); else setDirection(0, dy>0?1:-1);
      touchStart=null;
      if(!running||gameOver||paused) startGame();
    }

    canvas.addEventListener('touchstart', onTouchStart, {passive:true});
    canvas.addEventListener('touchmove', onTouchMove, {passive:false});
    canvas.addEventListener('touchend', onTouchEnd, {passive:true});

    // Game loop with fixed timestep tied to BASE_TPS * speedMult
    let acc = 0, last = 0;

    function startGame(){
      if(gameOver){ resetGame(); }
      running = true; paused = false; hideOverlay(); ensureAudio();
      last = performance.now(); acc = 0; requestAnimationFrame(loop);
    }

    function loop(ts){
      if(!running){ return; }
      const dt = Math.min(100, ts - last); last = ts; acc += dt;
      const stepMs = 1000 / (BASE_TPS * speedMult);
      while(acc >= stepMs){
        tick(); acc -= stepMs;
      }
      render();
      requestAnimationFrame(loop);
    }

    function tick(){
      if(paused||gameOver) return;
      dir = nextDir;
      const curHead = snake[snake.length-1];
      const head = {x: curHead.x + dir.x, y: curHead.y + dir.y};

      // walls vs wrap behavior
      if(walls){
        if(head.x<0 || head.y<0 || head.x>=gridSize || head.y>=gridSize){ return endGame(); }
      } else {
        head.x = (head.x + gridSize) % gridSize;
        head.y = (head.y + gridSize) % gridSize;
      }

      // self collision
      const willEat = (head.x===apple.x && head.y===apple.y);
      for(let i=0;i<snake.length;i++){
        if(snake[i].x===head.x && snake[i].y===head.y){
          // Allow moving into current tail if it will shift away this tick
          const hitTail = (i===0);
          const tailWillMove = !willEat && pendingGrowth===0;
          if(hitTail && tailWillMove){ /* ok */ } else { return endGame(); }
        }
      }

      snake.push(head);
      // apple check
      if(willEat){
        score += 10; // smooth per-apple speed ramp
        const apples = score / 10;
        speedMult = Math.min(3.0, 1 + apples * 0.08);
        pendingGrowth += GROWTH; placeApple();
        if(navigator.vibrate) navigator.vibrate(25);
        beep('eat');
      }
      if(pendingGrowth>0){ pendingGrowth--; } else if(!willEat){ snake.shift(); }

      if(score>best){ best = score; localStorage.setItem('neon-snake-best', String(best)); }
      updateHUD();
    }

    function endGame(){
      gameOver = true; running = false; showOverlay('Game Over — tap or press Space to retry');
      if(navigator.vibrate) navigator.vibrate([30,40,30]);
      beep('over');
    }

    // Drawing helpers
    function clear(){
      ctx.clearRect(0,0,canvas.width/dpr, canvas.height/dpr);
      const size = cell * gridSize;
      // subtle neon grid
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = '#16162a';
      ctx.lineWidth = 1;
      for(let i=0;i<=gridSize;i++){
        const p = Math.floor(i*cell)+.5;
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,size); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(size,p); ctx.stroke();
      }
      ctx.restore();

      // inner glow border
      const r = 12;
      const grd = ctx.createLinearGradient(0,0,0,size);
      grd.addColorStop(0,'rgba(124,0,255,.15)');
      grd.addColorStop(1,'rgba(0,246,255,.12)');
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,size, size);
    }

    function drawSegment(x,y,alpha){
      const px = x*cell, py=y*cell, pad = Math.floor(cell*0.12), w = cell - pad*2;
      ctx.save();
      ctx.shadowColor = 'rgba(0,229,255,0.75)';
      ctx.shadowBlur = 12;
      ctx.fillStyle = `rgba(0,229,255,${alpha})`;
      roundRect(ctx, px+pad, py+pad, w, w, Math.min(8, Math.floor(cell*0.25)));
      ctx.fill();
      ctx.restore();

      // center highlight
      ctx.save();
      const grd = ctx.createRadialGradient(px+cell/2, py+cell/2, 2, px+cell/2, py+cell/2, cell/1.4);
      grd.addColorStop(0,'rgba(255,255,255,0.18)');
      grd.addColorStop(1,'rgba(0,229,255,0.0)');
      ctx.fillStyle = grd; ctx.fillRect(px,py,cell,cell); ctx.restore();
    }

    function drawApple(x,y){
      const px=x*cell, py=y*cell;
      ctx.save();
      ctx.shadowColor = 'rgba(255,41,101,0.8)'; ctx.shadowBlur = 16;
      ctx.fillStyle = 'rgba(255,41,101,0.95)';
      const pad = Math.floor(cell*0.18);
      roundRect(ctx, px+pad, py+pad, cell-2*pad, cell-2*pad, Math.min(8, Math.floor(cell*0.25)));
      ctx.fill();
      // sparkle
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.beginPath(); ctx.arc(px+cell*0.65, py+cell*0.35, Math.max(1,cell*0.06), 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function roundRect(c, x, y, w, h, r){
      c.beginPath();
      c.moveTo(x+r,y);
      c.arcTo(x+w,y,x+w,y+h,r);
      c.arcTo(x+w,y+h,x,y+h,r);
      c.arcTo(x,y+h,x,y,r);
      c.arcTo(x,y,x+w,y,r);
      c.closePath();
    }

    function render(){
      clear();
      // draw apple
      drawApple(apple.x, apple.y);
      // draw snake with tail fade
      const n = snake.length;
      for(let i=0;i<n;i++){
        const alpha = 0.55 + 0.45 * (i/(n-1||1));
        drawSegment(snake[i].x, snake[i].y, alpha);
      }
    }

    window.addEventListener('resize', () => {
      const oldSize = gridSize; computeGrid();
      // keep snake and apple within bounds after resize (wrap)
      snake = snake.map(s=> ({x:(s.x%gridSize+gridSize)%gridSize, y:(s.y%gridSize+gridSize)%gridSize}));
      apple = {x:(apple.x%gridSize+gridSize)%gridSize, y:(apple.y%gridSize+gridSize)%gridSize};
    });

    // Initialize
    computeGrid();
    resetGame();
  })();
  </script>
</body>
</html>
